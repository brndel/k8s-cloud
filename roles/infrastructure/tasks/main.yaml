- name: Set dynamic facts
  vars:
    suffix: "{{ domain | community.dns.get_public_suffix }}"
    main_name: "{{ domain | replace(suffix, '') | split('.') | last }}"
  ansible.builtin.set_fact:
    k8s_api_host: "{{ subdomains.k8s_api }}.{{ domain }}"
    charts_dir: "{{ playbook_dir }}/charts"
    cluster_name: "{{ domain | replace('.', '-') }}-cluster"
    registered_domain: "{{ main_name }}{{ suffix }}"
    host_kubeconfig: "{{ ansible_env.KUBECONFIG }}"
    kubeconfig: "{{ ansible_env.KUBECONFIG }}"

- name: Print domain info
  ansible.builtin.debug:
    msg: "Setting up cluster '{{ cluster_name }}' for domain '{{ domain }}' on registered domain '{{ registered_domain }}'"

- name: Switch to host cluster context via kubectl
  when: "host_cluster_name"
  environment:
    KUBECONFIG: "{{ host_kubeconfig }}"
  block:
    - name: Get current kubectl context via command
      ansible.builtin.command: "kubectl config current-context"
      changed_when: false
      register: default_ctx

    - name: Set kubectl context to supplied value
      ansible.builtin.command: "kubectl config use-context {{ host_cluster_name }}"
      changed_when: "host_cluster_name != default_ctx.stdout"

- name: Ensure cluster labels are applied to nodes
  environment:
    K8S_AUTH_KUBECONFIG: "{{ host_kubeconfig }}"
  block:
    - name: Add cluster label to inventory node
      loop: "{{ cluster_nodes }}"
      kubernetes.core.k8s:
        state: patched
        kind: Node
        name: "{{ item }}"
        definition:
          metadata:
            labels: "{{ {cluster_name: '1'} }}"

    - name: Add topology labels to inventory node
      loop: "{{ cluster_nodes }}"
      vars:
        region: "{{ hostvars[item].region | default('eu') }}"
        zone: "{{ hostvars[item].zone | default('eu-1') }}"
      kubernetes.core.k8s:
        state: patched
        kind: Node
        name: "{{ item }}"
        definition:
          metadata:
            labels:
              topology.kubernetes.io/region: "{{ region }}"
              topology.kubernetes.io/zone: "{{ zone }}"

    - name: Add backbone label to inventory node
      loop: "{{ backbone_nodes }}"
      kubernetes.core.k8s:
        state: patched
        kind: Node
        name: "{{ item }}"
        definition:
          metadata:
            labels:
              backbone: "1"

    - name: Add cluster ingress label to inventory node
      loop: "{{ ingress_nodes }}"
      kubernetes.core.k8s:
        state: patched
        kind: Node
        name: "{{ item }}"
        definition:
          metadata:
            labels:
              svccontroller.k3s.cattle.io/enablelb: "true"
              svccontroller.k3s.cattle.io/lbpool: "{{ cluster_name }}"

    - name: Add cluster storage label to inventory node
      loop: "{{ storage_nodes }}"
      vars:
        storage_key: "{{ cluster_name }}-storage"
      kubernetes.core.k8s:
        state: patched
        kind: Node
        name: "{{ item }}"
        definition:
          metadata:
            labels: "{{ {storage_key: '1'} }}"

- name: Ensure vcluster for domain exists and selected in kubeconfig
  when: "vcluster"
  environment:
    K8S_AUTH_KUBECONFIG: "{{ host_kubeconfig }}"
    KUBECONFIG: "{{ host_kubeconfig }}"
  block:
    - name: Reconcile base git repo
      ansible.builtin.command: "flux reconcile source git base-repo -n flux-system"
      changed_when: true

    - name: Ensure vcluster HelmRelease exists
      ansible.builtin.include_tasks:
        file: deploy-chart.yaml
        apply:
          vars:
            chart:
              name: vcluster-stack
              namespace: "{{ cluster_name }}"
              chart_values:
                cluster_name: "{{ cluster_name }}"
                host: "{{ k8s_api_host }}"
                oidc_client:
                  idp_url: "https://{{ subdomains.keycloak }}.{{ domain }}/realms/master"
                  id: cluster-oidc
            kubeconfig: "{{ host_kubeconfig }}"

    - name: Wait for vcluster deployment to become ready
      kubernetes.core.k8s_info:
        kind: Deployment
        namespace: "{{ cluster_name }}"
        name: vcluster
        wait: true
        wait_timeout: 600

    - name: Gather facts on listening ports
      community.general.listen_ports_facts:
        include_non_listening: true

    - name: Select port to forward vcluster api over
      vars:
        used_ports: "{{ ansible_facts.tcp_listen | map(attribute='port') | list }}"
      ansible.builtin.set_fact:
        vcluster_port: "{{ range(5000, 30000) | list | difference(used_ports) | random }}"

    - name: Generate kubeconfig for vcluster
      vars:
        connect_flags:
          - "--namespace={{ cluster_name }}"
          - "--local-port={{ vcluster_port }}"
          - "--update-current=false"
          - "--kube-config=/tmp/virtual-kubeconfig.yaml"
          - "--kube-config-context-name={{ cluster_name }}"
      ansible.builtin.shell: "nohup vcluster connect vcluster {{ connect_flags | join(' ') }} </dev/null >/dev/null 2>&1 &"
      changed_when: true

    - name: Print port where vcluster listens
      ansible.builtin.debug:
        msg: "VCluster API is being forwarded to port {{ vcluster_port }} on localhost"

    - name: Wait for port-forwarded vcluster API to become available
      ansible.builtin.wait_for:
        host: localhost
        port: "{{ vcluster_port }}"
        timeout: 120

    - name: Activate vcluster kubeconfig
      ansible.builtin.set_fact:
        kubeconfig: /tmp/virtual-kubeconfig.yaml

    - name: Wait for vcluster coredns deployment to become available
      environment:
        K8S_AUTH_KUBECONFIG: "{{ kubeconfig }}"
      kubernetes.core.k8s_info:
        kind: Deployment
        namespace: kube-system
        name: coredns
        wait: true
        wait_timeout: 120

- name: Ensure kubeconfig file is available on local machine
  block:
    - name: Determine kubeconfig context name
      vars:
        host_ctx: "{{ host_cluster_name | ternary(host_cluster_name, default_ctx) }}"
      ansible.builtin.set_fact:
        ctx_name: "{{ vcluster | ternary(cluster_name, host_ctx) }}"

    - name: Use remote kubeconfig file as basis
      block:
        - name: Copy remote kubeconfig file
          ansible.builtin.copy:
            remote_src: true
            src: "{{ kubeconfig }}"
            dest: /tmp/public-kubeconfig.yaml
            mode: '0644'

        - name: List remote kubeconfig contexts
          environment:
            KUBECONFIG: /tmp/public-kubeconfig.yaml
          ansible.builtin.command: "kubectl config get-contexts -o name"
          register: all_ctx
          changed_when: false

        - name: Delete all other remote contexts
          loop: "{{ all_ctx.stdout_lines }}"
          when: "item != ctx_name"
          environment:
            KUBECONFIG: /tmp/public-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-context {{ item }}"
          changed_when: true

        - name: Delete all other remote clusters
          loop: "{{ all_ctx.stdout_lines }}"
          when: "item != ctx_name"
          environment:
            KUBECONFIG: /tmp/public-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-cluster {{ item }}"
          changed_when: true

        - name: Delete all other remote users
          loop: "{{ all_ctx.stdout_lines }}"
          when: "item != ctx_name"
          environment:
            KUBECONFIG: /tmp/public-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-user {{ item }}"
          changed_when: true

    - name: Check for local kubeconfig
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/{{ local_kubeconfig }}"
      register: local_kubeconfig_file

    - name: Copy and merge local config file
      when: "local_kubeconfig_file.stat.exists"
      block:
        - name: Copy local kubeconfig to remote
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ local_kubeconfig }}"
            dest: /tmp/local-kubeconfig.yaml
            mode: '0644'

        - name: Delete existing context in local config
          environment:
            KUBECONFIG: /tmp/local-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-context {{ ctx_name }}"
          changed_when: true
          failed_when: false

        - name: Delete existing cluster in local config
          environment:
            KUBECONFIG: /tmp/local-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-cluster {{ ctx_name }}"
          changed_when: true
          failed_when: false

        - name: Delete existing user in local config
          environment:
            KUBECONFIG: /tmp/local-kubeconfig.yaml
          ansible.builtin.command: "kubectl config delete-user {{ ctx_name }}"
          changed_when: true
          failed_when: false

        - name: Merge local kubeconfig with remote
          environment:
            KUBECONFIG: "/tmp/public-kubeconfig.yaml:/tmp/local-kubeconfig.yaml"
          ansible.builtin.command:
            argv:
              - kubectl
              - config
              - view
              - --flatten
          register: merged_kubeconfig
          changed_when: false

        - name: Save merged kubeconfig to file
          ansible.builtin.copy:
            content: "{{ merged_kubeconfig.stdout }}"
            dest: /tmp/public-kubeconfig.yaml
            mode: '0644'

    - name: Change server address of copied kubeconfig to public cluster FQN
      environment:
        KUBECONFIG: /tmp/public-kubeconfig.yaml
      ansible.builtin.command:
        argv:
          - kubectl
          - config
          - set-cluster
          - "{{ ctx_name }}"
          - "--server=https://{{ k8s_api_host }}"
      changed_when: true

    - name: Download kubeconfig file
      ansible.builtin.fetch:
        src: /tmp/public-kubeconfig.yaml
        dest: "{{ playbook_dir }}/kubeconfig.yaml"
        flat: true

- name: Ensure GitOps via FluxCD is setup
  environment:
    K8S_AUTH_KUBECONFIG: "{{ kubeconfig }}"
    KUBECONFIG: "{{ kubeconfig }}"
  block:
    - name: Check if FluxCD release already exists
      kubernetes.core.helm_info:
        name: fluxcd
        release_namespace: flux-system
      register: existing_fluxcd

    - name: Deploy FluxCD
      when: "existing_fluxcd.status is undefined or existing_fluxcd.status.keys() | length == 0"
      kubernetes.core.helm:
        wait: true
        timeout: 10m
        name: fluxcd
        release_namespace: flux-system
        create_namespace: true
        chart_repo_url: https://fluxcd-community.github.io/helm-charts
        chart_ref: flux2
        chart_version: "^2"
        values:
          policies:
            create: false

    - name: Ensure base GitRepository exists
      kubernetes.core.k8s:
        wait: true
        definition:
          apiVersion: source.toolkit.fluxcd.io/v1
          kind: GitRepository
          metadata:
            name: base-repo
            namespace: flux-system
          spec:
            interval: 1h
            url: "{{ base_repo }}"
            ref:
              branch: "{{ base_branch }}"

    - name: Reconcile base git repo
      ansible.builtin.command: "flux reconcile source git base-repo -n flux-system"
      changed_when: true

- name: Ensure components with CRDs and other hard dependecies are bootstrapped
  ansible.builtin.include_tasks:
    file: bootstrap-chart.yaml
    apply:
      vars:
        chart: "{{ item }}"
        kubeconfig: "{{ kubeconfig }}"
  loop:
    - name: storage-stack
      namespace: longhorn-system
    - name: cert-stack
      namespace: cert-system
    - name: telemetry-stack
      namespace: telemetry-system

- name: Ensure zoning tags are applied to Longhorn nodes
  environment:
    K8S_AUTH_KUBECONFIG: "{{ host_kubeconfig }}"
  block:
    - name: Get list of current Longhorn node tags
      loop: "{{ storage_nodes }}"
      kubernetes.core.k8s_info:
        api_version: longhorn.io/v1beta2
        kind: Node
        namespace: longhorn-system
        name: "{{ item }}"
        wait: true
        wait_timeout: 180
        wait_condition:
          type: Ready
          status: "True"
      register: lhn_info

    - name: Ensure tags are set on all Longhorn nodes in inventory
      loop: "{{ lhn_info.results }}"
      loop_control:
        label: "{{ item.item }}"
      vars:
        existing_tags: "{{ item.resources[0].spec.tags }}"
        node: "{{ item.resources[0].metadata.name }}"
        region: "{{ hostvars[node].region | default('eu') }}"
        zone: "{{ hostvars[node].zone | default('eu-1') }}"
        cluster_tag: "{{ cluster_name }}"
        region_tag: "{{ ('%s.%s' | format(region, cluster_tag)) }}"
        zone_tag: "{{ ('%s.%s' | format(zone, cluster_tag)) }}"
        backbone_tag: "{{ ('backbone.%s' | format(cluster_tag)) if node in backbone_nodes else false }}"
        # Assuming here that regions and zones do not share names.
        backbone_region_tag: "{{ ('backbone.%s' | format(region_tag)) if backbone_tag else false }}"
        backbone_zone_tag: "{{ ('backbone.%s' | format(zone_tag)) if backbone_tag else false }}"
        new_tags: "{{ [cluster_tag, backbone_tag, region_tag, zone_tag, backbone_region_tag, backbone_zone_tag] | select() }}"
      kubernetes.core.k8s:
        state: patched
        api_version: longhorn.io/v1beta2
        kind: Node
        namespace: longhorn-system
        name: "{{ node }}"
        definition:
          spec:
            tags: "{{ (existing_tags + new_tags) | unique | list }}"
      register: lhn_patch_result
      retries: 6 # Longhorn CRD webhook tends to be unavailable at times.
      delay: 20
      until: "lhn_patch_result is not failed"

- name: Ensure all required secrets exist
  environment:
    K8S_AUTH_KUBECONFIG: "{{ kubeconfig }}"
  kubernetes.core.k8s:
    wait: true
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "{{ item.name }}"
        namespace: kube-system
      type: Opaque
      data:
        secret: "{{ vars[item.inventoryKey] | b64encode }}"
  loop:
    - inventoryKey: smtp_password
      name: smtp
    - inventoryKey: s3_access_key_secret
      name: s3
    - inventoryKey: external_dns_token
      name: external-dns

- name: Ensure pre-restore infrastructure is fully set up
  ansible.builtin.include_tasks:
    file: deploy-chart.yaml
    apply:
      vars:
        chart: "{{ item }}"
        kubeconfig: "{{ kubeconfig }}"
  loop_control:
    label: "{{ item.name }} in {{ item.namespace }}"
  loop:
    - name: storage-stack
      namespace: longhorn-system
      chart_values:
        host: "{{ subdomains.longhorn }}.{{ domain }}"
        cluster_name: "{{ cluster_name }}"
        oauth2_proxy_host: "{{ subdomains.oauth2_proxy }}.{{ domain }}"
        admin_group: "cluster-admins"
        s3: "{{ backups.s3 | combine({'access_key_secret': {'name': 's3', 'namespace': 'kube-system', 'key': 'secret'}}) }}"

    - name: backup-stack
      namespace: backup-system
      chart_values:
        s3: "{{ backups.s3 | combine({'access_key_secret': {'name': 's3', 'namespace': 'kube-system', 'key': 'secret'}}) }}"

- name: Restore cluster from backup
  when: "backups.restore.enabled"
  vars:
    restore_name: "{{ backups.restore.backup_name | ternary(backups.restore.backup_name, backups.restore.schedule_name) }}"
  block:
    - name: Wait for backup resource to be synced from s3
      when: "backups.restore.backup_name"
      kubernetes.core.k8s_info:
        api_version: velero.io/v1
        kind: Backup
        namespace: backup-system
        name: "{{ backups.restore.backup_name }}"
      register: backup_get_result
      retries: 10 # Velero may need time to load the backup from s3.
      delay: 20
      until: "backup_get_result.resources | length > 0"

    - name: Check if restoration for given backup already exists
      kubernetes.core.k8s_info:
        api_version: velero.io/v1
        kind: Restore
        namespace: backup-system
        name: "{{ restore_name }}"
      register: existing_restore

    - name: Apply backup restoration
      when: "existing_restore.resources | length == 0"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      ansible.builtin.command:
        argv:
          - velero
          - restore
          - create
          - "{{ restore_name }}"
          - "--namespace=backup-system"
          - "--from-schedule={{ backups.restore.backup_name | ternary('', backups.restore.schedule_name) }}"
          - "--from-backup={{ backups.restore.backup_name }}"
          - "--include-resources={{ backups.restore.included_resources | join(',') }}"
          - "--restore-volumes=true"
          - "--selector"
          - "owner notin (helm)"
          - "--wait"
      changed_when: true

- name: Ensure remaining infrastructure is fully set up
  ansible.builtin.include_tasks:
    file: deploy-chart.yaml
    apply:
      vars:
        chart: "{{ item }}"
        kubeconfig: "{{ kubeconfig }}"
  loop_control:
    label: "{{ item.name }} in {{ item.namespace }}"
  loop:
    - name: admin-rbac
      namespace: kube-system
      chart_values:
        admin_group: "cluster-admins"

    - name: k3s-auto-upgrade
      namespace: upgrade-system

    - name: cert-stack
      namespace: cert-system
      chart_values:
        admin_email: "{{ mail.admin_address }}"
        base_repo: "{{ base_repo }}"
        base_branch: "{{ base_branch }}"
        letsencrypt_staging: "{{ letsencrypt_staging }}"

    - name: ingress-stack
      namespace: ingress-system
      chart_values:
        cluster_name: "{{ cluster_name }}"

    - name: control-stack
      namespace: kube-system
      chart_values:
        host: "{{ subdomains.k8s_dashboard }}.{{ domain }}"
        oauth2_proxy_host: "{{ subdomains.oauth2_proxy }}.{{ domain }}"
        admin_group: "cluster-admins"

    - name: dns-stack
      namespace: dns-system
      chart_values:
        domain: "{{ registered_domain }}"
        token_secret:
          namespace: kube-system
          name: external-dns
          key: secret

    - name: sso-stack
      namespace: sso-system
      chart_values:
        domain: "{{ domain }}"
        org: "{{ org }}"
        hosts:
          keycloak: "{{ subdomains.keycloak }}.{{ domain }}"
          authproxy: "{{ subdomains.oauth2_proxy }}.{{ domain }}"
        cluster_client:
          id: cluster-oidc
          redirect_uris:
            - "https://{{ subdomains.grafana }}.{{ domain }}/login/generic_oauth"
            - "https://{{ subdomains.weave_gitops }}.{{ domain }}/oauth2/callback"
        smtp: "{{ mail.smtp | combine({'password_secret': {'name': 'smtp', 'namespace': 'kube-system', 'key': 'secret'}}) }}"
        admin_group: "cluster-admins"
        admin_email: "{{ mail.admin_address }}"
        letsencrypt_staging: "{{ letsencrypt_staging }}"

    - name: telemetry-stack
      namespace: telemetry-system
      chart_values:
        domain: "{{ domain }}"
        org: "{{ org }}"
        host: "{{ subdomains.grafana }}.{{ domain }}"
        oidc_client:
          idp_url: "https://{{ subdomains.keycloak }}.{{ domain }}/realms/master"
          id: "cluster-oidc"
          secret:
            namespace: sso-system
            name: cluster-oidc
            key: secret
        admin_email: "{{ mail.admin_address }}"
        admin_group: "cluster-admins"
        smtp: "{{ mail.smtp | combine({'password_secret': {'name': 'smtp', 'namespace': 'kube-system', 'key': 'secret'}}) }}"
        node_endpoints: "{{ groups['all'] }}"
        letsencrypt_staging: "{{ letsencrypt_staging }}"
        k3s: true

    - name: cicd-stack
      namespace: flux-system
      chart_values:
        host: "{{ subdomains.weave_gitops }}.{{ domain }}"
        oidc_client:
          idp_url: "https://{{ subdomains.keycloak }}.{{ domain }}/realms/master"
          id: "cluster-oidc"
          secret:
            namespace: sso-system
            name: cluster-oidc
            key: secret
        letsencrypt_staging: "{{ letsencrypt_staging }}"

- name: Expose k8s API via Ingress
  environment:
    K8S_AUTH_KUBECONFIG: "{{ kubeconfig }}"
  kubernetes.core.k8s:
    wait: true
    definition:
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: k8s-api
        namespace: default
        annotations:
          nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          kubernetes.io/tls-acme: "true"
      spec:
        tls:
          - hosts:
              - "{{ k8s_api_host }}"
            secretName: k8s-api-cert
        rules:
          - host: "{{ k8s_api_host }}"
            http:
              paths:
                - backend:
                    service:
                      name: kubernetes
                      port:
                        number: 443
                  path: /
                  pathType: ImplementationSpecific
  register: k8s_ingress_result
  retries: 6 # NGINX webhook tends to be unavailable at times.
  delay: 20
  until: "k8s_ingress_result is not failed"

- name: Reset kubectl context
  when: "host_cluster_name and default_ctx is defined"
  environment:
    KUBECONFIG: "{{ host_kubeconfig }}"
  ansible.builtin.command: "kubectl config use-context {{ default_ctx.stdout }}"
  changed_when: "host_cluster_name != default_ctx.stdout"

- name: Cleanup port forwarding
  when: "vcluster"
  block:
    - name: Get PIDs of running vcluster port-forwarders
      community.general.pids:
        name: vcluster
      register: vcluster_pids

    - name: Terminate extraneous port-forwarders to vcluster
      when: "vcluster_pids.pids | length > 1"
      loop: "{{ vcluster_pids.pids[:-1] }}"
      ansible.builtin.command: "kill -SIGTERM {{ item }}"
      changed_when: true
